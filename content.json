{"pages":[],"posts":[{"title":"Android-Studio使用阿里云镜像解决依赖下载慢的问题","text":"使用阿里云的镜像替换默认的镜像国内由于众所周知的原因导致Android Studio依赖下载过慢，使用阿里云的镜像能够有效解决这个问题 1234567891011121314151617181920212223242526buildscript { repositories { maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.5.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }}allprojects { repositories { maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'} google() jcenter() }}task clean(type: Delete) { delete rootProject.buildDir}","link":"/2019/12/12/Android-Studio%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Hexo博客更新主题后上传Git操作","text":"从GitHub上克隆主题(以next主题为例)在根目录下右键git bush here，输入： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 在站点配置文件（_config.yml） 中将主题改为新增主题1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 进入主题目录，更新git1cd themes/next 1git pull 执行更新1hexo clean 1hexo g 1hexo s 测试网址输入网址 http://localhost:4000 查看主题是否已更新，正常即可输入： 1hexo d 完成部署，然后打开个人域名网址即可。","link":"/2019/09/19/Hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98%E5%90%8E%E4%B8%8A%E4%BC%A0Git%E6%93%8D%E4%BD%9C/"},{"title":"Java中static作用及用法详解","text":"1. 概述在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的，而所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。在Java程序里面，所有的东西都是对象，而对象的抽象就是类，对于一个类而言，如果要使用他的成员，那么普通情况下必须先实例化对象后，通过对象的引用才能够访问这些成员，但是用static修饰的成员可以通过**类名加 “.” **进行直接访问。 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 2. 定义和使用格式类变量当 static 修饰成员变量时，该变量称为类变量（没被修饰的变量称为实例变量）。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 定义格式： 1static 数据类型 变量名; 举例： 1static String name; 比如说，基础班新班开班，学员报到。现在想为每一位新来报到的同学编学号（id），从第一名同学开始，id为1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关。 所以，我们可以这样定义一个静态变量numberOfStudent，代码如下： 123456789101112131415161718192021222324252627282930313233public class Student { private String name; private int age; // 学生的id private int id; // 类变量，记录学生数量，分配学号，初始化为0 public static int numberOfStudent = 0; public Student(String name, int age){ this.name = name; this.age = age; // 通过 numberOfStudent 给学生分配学号 this.id = ++numberOfStudent; } // 打印属性值 public void show(){ System.out.println(&quot;Student : name=&quot; + name + &quot;, age=&quot; + age + &quot;, sid=&quot; + id); }}public class StuDemo { public static void main(String[] args) { Student s1 = new Student(&quot;张三&quot;, 23); Student s2 = new Student(&quot;李四&quot;, 24); Student s3 = new Student(&quot;王五&quot;, 25); Student s4 = new Student(&quot;赵六&quot;, 26); s1.show(); // Student : name=张三, age=23, sid=1 s2.show(); // Student : name=李四, age=24, sid=2 s3.show(); // Student : name=王五, age=25, sid=3 s4.show(); // Student : name=赵六, age=26, sid=4 }} 静态方法当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议直接使用类名来调用，而不需要创建类的对象。调用方式非常简单。 定义格式： 123修饰符 static 返回值类型 方法名 (参数列表){ // 执行语句} 举例：在Student类中定义静态方法 123public static void showNum() { System.out.println(&quot;num:&quot; + numberOfStudent);} 静态方法调用的注意事项： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。但是，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this或super关键字。 小贴士：静态方法只能访问静态成员 调用格式被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 格式： 12345// 访问类变量类名.类变量名； // 调用静态方法类名.静态方法名(参数)； 调用演示： 12345678public class StuDemo2 { public static void main(String[] args) { // 访问类变量 System.out.println(Student.numberOfStudent); // 调用静态方法 Student.showNum(); }} 3. 静态代码块static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 格式： 12345public class test { static { //执行语句 }} 作用：给类变量进行初始化赋值。用法演示，代码如下： 12345678910111213public class Game { public static int number; public static ArrayList&lt;String&gt; list; static { // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); }} 4. 总结有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。 static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。","link":"/2020/07/26/Java%E4%B8%ADstatic%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"title":"博客自定义域名教程","text":"我的博客是托管在Github Pages上，默认的域名便是 yourname.github.io ，如何将域名变得更简单和更有个性呢，这就是自定义域名。我在阿里云上买了一个 .top 为后缀的域名，目前完整域名为 lazypie.top 。看起来还是比默认的 github.io 域名舒服的呀，接下来就讲讲设置自定义域名的步骤。 域名控制台设置购买域名可选择的网站很多，由于我是在阿里云购买的，这里拿阿里云举例。购买完你的域名和认证完成后，进入域名控制台，选择操作中的解析: 点击添加记录，记录类型选择 CNAME ，主机记录填写 www ，解析线路 默认 ，记录值填写 yourname.github.io (这里是你原来的博客域名)，TTL填写 10分钟 ： 重复以上步骤再添加一条记录，主机记录改为 @ ，其他不变，最后如图下： Github设置打开GitHub，进入你托管博客的仓库页面，点击设置： 往下滑找到Github Pages板块，在Custom domain下面的输入框输入你的自定义域名后点击save保存： 到这里你应该可以用你的自定义域名打开你的博客页面了，但是将来重新部署后可能又会打不开，这时候就要看下面的设置了。 适用于GitHub仓库里丢失了CNAME文件和博客根目录/source下丢失CNAME文件 添加CNAME文件打开GitHub，进入你托管博客的仓库页面，点击 Create new file : 输入你的自定义域名后划到下面点击 Commit new file 提交文件: 接下来打开你的博客根目录/source，新建一个名为 CNAME 的文件，在里面输入你的自定义域名（新建一个txt文档，输入完后重命名文件删掉文件后缀名即可）： 如果你使用的是mac系统，则可以通过终端新建一个无后缀的文件 12# 在source目录下echo [你的域名] &gt; CNAME 到这里就完成自定义域名啦，大概等一小会就ok了。","link":"/2019/09/19/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E6%95%99%E7%A8%8B/"},{"title":"Java核心技术笔记","text":"本文大多数内容基于Java核心技术卷一卷二两书，记录下本人经常忘记但却有用的知识点 一、继承 强制类型转换（p167-168） 只能在继承层次内进行强制类型转换。 在将父类强制转换成子类时，应该使用instanceof进行检查。 一般情况下，最好尽量少用强制类型转换和instanceof运算符。 相等测试与继承（p176-178）如果隐式和显式的参数不属于同一个类，equals方法如何处理呢？编写一个完美的equals方法的建议（idea可自动生成）： 显式参数命名为 otherObject，稍后需要将它强制转换成另一个名为 other 的变量。 检测 this 与otherObject 是否相等： 1if (this == otherObject) return true; 这条语句只是一个优化。实际上，这是一种经常采用的形式。因为检查身份要比逐个比较宇段开销小。 检测 otherObject 是否为 null，如果为null，返回false。这项检测是很必要的。 1if (otherObject == null) return false; 比较this与otherobject 的类。如果 eauals 的语义可以在子类中改变，就使用getClass 检测： 1if (getClass() != otherObject.getClass()) return false; 如果所有的子类都有相同的相等性语义，可以使用 instanceof 检测： 1if (!(otherObject instanceof ClassName)) return false; 将otherobject 强制转换为相应类类型的变量： 1ClassName other = (ClassName) otherObject; 现在根据相等性概念的要求来比较字段。使用二比较基本类型字段， 使用 Objects.equals 比较对象字段。如果所有的字段都匹配，就返回true；否则返回 false。 1return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2) &amp;&amp; ...; 如果在子类中重新定义equals，就要在其中包含一个 super.equals(other)调用。 二、接口 解决默认方法冲突（default）（p231-333）如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义同样的方法，会发生什么情况呢？ 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。 接口冲突。一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必领覆盖这个方法来解决冲突。 假如一个类实现了两个接口（两个接口都提供了默认实现），里面有两个相同的方法，Java编译器会报告一个错误，让程序员来解决这个二义性问题。 如果两个接口没有提供默认实现，那么就不存在冲突，实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，则这个类本身就是抽象的。 三、lambda表达式 概念语法lambda表达式就是一个代码块，以及必须传入代码的变量规范。lambda表达式形式：参数，箭头(-&gt;)，表达式。 函数式接口对于只有一个抽象方法的接口（函数式接口），需要这种接口的的对象时，就可以提供一个lambda表达式。 最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。实际上，在Java中，对lambda表达式所能做的也只是转换为函数式接口。 方法引用（p247-249）只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。 要用**::运算符**分隔方法名与对象或类名。主要有三种情况： Object::instanceMethod Class::instanceMethod Class::staticMethod 在第1种情况下，方法引用等价于向方法传递参数的lambda表达式。对于System.out::println对象是System.out，所以方法表达式等价于x -&gt; System.out.printIn(x)。 对于第2种情况，第1个参数会成为方法的隐式参数。例如，String::compareToIgnoreCase等同(x, y) -&gt; x.compareToIgnoreCase(y)。 在第3种情况下，所有参数都传递到静态方法：Math::pow等价于(x, y) -&gt; Math. pow(x, y)。 变量作用域lambda表达式中捕获的变量必须实际上是事实最终变量（这个变量初始化之后就不会再为它赋新值）。 处理lambda表达式（p252-254）使用lambda表达式的重点是延迟执行。之所以希望以后再执行，有如下原因： 在一个单独的线程中运行代码 多次运行代码 在算法的适当位置运行代码（例如，排序中的比较操作） 发生某种情况时执行代码（点击了一个按钮，数据到达等等） 只在必要时才运行代码 四、内部类 使用内部类的两个原因： 内部类可以对同一个包中的其他类隐藏 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据 五、异常 异常分类Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型异常，所有其他的异常称为检查型异常。 声明检查型异常如果父类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常。 抛出/捕获异常一般来说，要捕获(try/catch)那些你知道如何处理的异常，而继续传播(throws)那些你不知道怎么样处理的异常。 再次抛出异常与异常链可以在catch子句中抛出一个异常。ServletException就是这样一个异常类型的例子。执行一个servlet的代码可能不想知道发生错误的细节原因，但希望明确的知道servlet是否有问题，更好的处理方法如下，把原始异常设置为新异常的“原因”： 1234567try { access the database} catch (SQLException original) { var e = new ServletException(&quot;database error&quot;); e.initCause(original); throw e;} 捕获到这个异常时，可以使用下面这条语句获取原始异常： 1Throwable original = caughtExecption.getCause(); 强烈建议使用这种包装技术。这样可以在子系统中抛出高层异常，而不会丢失原始异常的细节。 finally子句finally子句的体要用于清理资源。不要把改变控制流的语句 (return, throw, break, continue) 放在finally子句中。 try-with-resources语句（p292-294）在实际中，try-with-resources 语句可能比 finally子句更常用。 try-with-resources 语句（带资源的try语句）的最简形式为： 123try(Resources res = ...) { work with res} 典型例子（读取一个文件中的所有单词）: 12345try(var in = new Scanner( new FileInputStream(&quot;/usr/share/dict/words&quot;), StandardCharsets.UTF_8)) { while(in.hasNext()) System.out.println(in.next());} 这个块正常退出时，或者存在一个异常时，都会调用 in.close() 方法，就好像使用了finally块一样。 使用异常的技巧（p298-300） 异常处理不能代替简单的测试 不要过分地细化异常 充分利用异常层次结构 不要压制异常 在检测错误时，“苛刻”要比放任更好 不要羞于传递异常 六、泛型 泛型方法泛型方法语法如下： 1public &lt;T&gt; T func(T obj) {} 是否拥有泛型方法，与其所在的类是否是泛型没有关系。 类型擦除Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。 那么，类型擦除做了什么呢？它做了以下工作： 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。 擦除出现的类型声明，即去掉 &lt;&gt; 的内容。比如 T get() 方法声明就变成了 Object get() ；List&lt;String&gt; 就变成了 List。如有必要，插入类型转换以保持类型安全。 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。 转换泛型方法对于Java泛型的转换，需要记住以下几个事实： 虚拟机中没有泛型，只有普通的类和方法。 所有的类型参数都会替换为它们的限定类型。 会合成桥方法来保持多态。 为保持类型安全性，必要时会插入强制类型转换。 限制与局限性 不能用基本类型实例化类型参数 12Pair&lt;double&gt; // ERRORPair&lt;Double&gt; // RIGHT 运行时类型查询只适用于原始类型（不能使用类型转换或instanceof） 123if (a instanceof Pair&lt;String&gt;) // ERRORif (a instanceof Pair&lt;T&gt;) // ERRORPair&lt;String&gt; p = (Pair&lt;String&gt;) a; // warning，强制类型转换 不能创建参数化类型数组 1var table = new Pair&lt;String&gt;[10]; //error 不能实例化类型变量 1234public Pair() { first = new T(); // ERROR second = new T(); // ERROR} 不能在静态字段或方法中引用类型变量 1234567public class Singleton&lt;T&gt; { private static T singleInstance; // ERROR private static T getSingleInstance { // ERROR if (singleInstance == null) return singleInstance; }} 不能创建、catch 或 throw 参数化类型对象 12345// Extends Throwable indirectlyclass MathException&lt;T&gt; extends Exception { /* ... */ } // ERROR// Extends Throwable directlyclass QueueFullException&lt;T&gt; extends Throwable { /* ... */ // ERROR 12345678public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) { try { for (J job : jobs) // ... } catch (T e) { // compile-time error // ... }} 七、集合","link":"/2021/09/30/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"title":"Java多态性详解","text":"一、什么是多态1.面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 2.多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 3.实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 4.多态的作用：消除类型之间的耦合关系。 5.现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 举例： 12345678910111213/** 用连接数据库驱动举例*/class Driver { //形参conn可以为conn = new MySqlConnection() //也可以为conn = new OracleConnection() public void doData(Connection conn) { //连接步骤 conn.method1(); conn.method2(); conn.method3(); }} 由上述例子可以得知，使用多态性，大大节省了连接不同驱动所需要的代码，只需要在同一个方法实现。 二、实现条件多态性的使用前提： 类的继承关系 子类对父类方法的重写 父类引用指向子类 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结：编译看左边（父类），运行看右边（子类）","link":"/2021/04/26/Java%E5%A4%9A%E6%80%81%E6%80%A7%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"博客相关","slug":"博客相关","link":"/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"}]}